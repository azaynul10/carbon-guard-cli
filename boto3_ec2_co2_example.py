#!/usr/bin/env python3
"""
Boto3 EC2 CO2 Calculator - Core implementation for fetching EC2 data and calculating emissions
"""

import boto3
from datetime import datetime, timedelta
from typing import List, Dict, Any

def fetch_ec2_instances_boto3(region: str = 'us-east-1') -> List[Dict[str, Any]]:
    """
    Fetch EC2 instances using boto3
    
    Args:
        region: AWS region to query
        
    Returns:
        List of instance dictionaries
    """
    # Initialize EC2 client
    ec2_client = boto3.client('ec2', region_name=region)
    
    try:
        # Fetch running instances
        response = ec2_client.describe_instances(
            Filters=[
                {'Name': 'instance-state-name', 'Values': ['running']}
            ]
        )
        
        instances = []
        for reservation in response['Reservations']:
            for instance in reservation['Instances']:
                instance_data = {
                    'InstanceId': instance['InstanceId'],
                    'InstanceType': instance['InstanceType'],
                    'LaunchTime': instance['LaunchTime'],
                    'State': instance['State']['Name'],
                    'AvailabilityZone': instance['Placement']['AvailabilityZone'],
                    'Tags': {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])},
                    'Platform': instance.get('Platform', 'linux')  # Windows instances have 'windows' platform
                }
                instances.append(instance_data)\n        \n        return instances\n        \n    except Exception as e:\n        print(f\"Error fetching EC2 instances: {e}\")\n        return []\n\ndef fetch_cloudwatch_instance_hours(instance_id: str, start_time: datetime, \n                                   end_time: datetime, region: str = 'us-east-1') -> float:\n    \"\"\"\n    Fetch instance running hours from CloudWatch using boto3\n    \n    Args:\n        instance_id: EC2 instance ID\n        start_time: Start time for metrics\n        end_time: End time for metrics\n        region: AWS region\n        \n    Returns:\n        Number of hours the instance was running\n    \"\"\"\n    cloudwatch_client = boto3.client('cloudwatch', region_name=region)\n    \n    try:\n        # Method 1: Use StatusCheckFailed metric to determine uptime\n        response = cloudwatch_client.get_metric_statistics(\n            Namespace='AWS/EC2',\n            MetricName='StatusCheckFailed',\n            Dimensions=[\n                {'Name': 'InstanceId', 'Value': instance_id}\n            ],\n            StartTime=start_time,\n            EndTime=end_time,\n            Period=3600,  # 1 hour periods\n            Statistics=['Average']\n        )\n        \n        datapoints = response.get('Datapoints', [])\n        if datapoints:\n            # Each datapoint represents 1 hour of uptime\n            return len(datapoints)\n        \n        # Method 2: Fallback - use CPUUtilization metric\n        response = cloudwatch_client.get_metric_statistics(\n            Namespace='AWS/EC2',\n            MetricName='CPUUtilization',\n            Dimensions=[\n                {'Name': 'InstanceId', 'Value': instance_id}\n            ],\n            StartTime=start_time,\n            EndTime=end_time,\n            Period=3600,\n            Statistics=['Average']\n        )\n        \n        datapoints = response.get('Datapoints', [])\n        if datapoints:\n            return len(datapoints)\n        \n        # Method 3: Calculate based on time difference (fallback)\n        time_diff = end_time - start_time\n        return time_diff.total_seconds() / 3600\n        \n    except Exception as e:\n        print(f\"Error fetching CloudWatch data for {instance_id}: {e}\")\n        # Return time-based calculation as fallback\n        time_diff = end_time - start_time\n        return time_diff.total_seconds() / 3600\n\ndef calculate_co2_emissions(instance_type: str, running_hours: float, \n                          carbon_intensity_kg_per_kwh: float = 0.3) -> Dict[str, float]:\n    \"\"\"\n    Calculate CO2 emissions for an EC2 instance\n    \n    Args:\n        instance_type: EC2 instance type (e.g., 't3.medium')\n        running_hours: Number of hours the instance was running\n        carbon_intensity_kg_per_kwh: Carbon intensity factor (default: 0.3 kg/kWh = 300g/kWh)\n        \n    Returns:\n        Dictionary with emission calculations\n    \"\"\"\n    # Power consumption estimates for different instance types (watts)\n    INSTANCE_POWER_WATTS = {\n        # Burstable Performance\n        't2.nano': 5, 't2.micro': 10, 't2.small': 20, 't2.medium': 40, 't2.large': 80,\n        't3.nano': 5, 't3.micro': 10, 't3.small': 20, 't3.medium': 40, 't3.large': 80,\n        't3.xlarge': 160, 't3.2xlarge': 320,\n        't4g.nano': 4, 't4g.micro': 8, 't4g.small': 16, 't4g.medium': 32, 't4g.large': 64,\n        \n        # General Purpose\n        'm5.large': 80, 'm5.xlarge': 160, 'm5.2xlarge': 320, 'm5.4xlarge': 640,\n        'm5.8xlarge': 1280, 'm5.12xlarge': 1920, 'm5.16xlarge': 2560, 'm5.24xlarge': 3840,\n        'm6i.large': 75, 'm6i.xlarge': 150, 'm6i.2xlarge': 300, 'm6i.4xlarge': 600,\n        \n        # Compute Optimized\n        'c5.large': 70, 'c5.xlarge': 140, 'c5.2xlarge': 280, 'c5.4xlarge': 560,\n        'c5.9xlarge': 1260, 'c5.12xlarge': 1680, 'c5.18xlarge': 2520, 'c5.24xlarge': 3360,\n        'c6i.large': 65, 'c6i.xlarge': 130, 'c6i.2xlarge': 260, 'c6i.4xlarge': 520,\n        \n        # Memory Optimized\n        'r5.large': 90, 'r5.xlarge': 180, 'r5.2xlarge': 360, 'r5.4xlarge': 720,\n        'r5.8xlarge': 1440, 'r5.12xlarge': 2160, 'r5.16xlarge': 2880, 'r5.24xlarge': 4320,\n        'r6i.large': 85, 'r6i.xlarge': 170, 'r6i.2xlarge': 340, 'r6i.4xlarge': 680,\n        \n        # Storage Optimized\n        'i3.large': 100, 'i3.xlarge': 200, 'i3.2xlarge': 400, 'i3.4xlarge': 800,\n        'i3.8xlarge': 1600, 'i3.16xlarge': 3200,\n        \n        # Accelerated Computing (GPU)\n        'p3.2xlarge': 3000, 'p3.8xlarge': 7000, 'p3.16xlarge': 14000,\n        'g4dn.xlarge': 500, 'g4dn.2xlarge': 750, 'g4dn.4xlarge': 1200,\n    }\n    \n    # Get power consumption (default to 50W if instance type not found)\n    power_watts = INSTANCE_POWER_WATTS.get(instance_type, 50)\n    \n    # Convert watts to kWh\n    power_kwh_per_hour = power_watts / 1000\n    \n    # Calculate total energy consumption\n    total_energy_kwh = power_kwh_per_hour * running_hours\n    \n    # Calculate CO2 emissions\n    co2_emissions_kg = total_energy_kwh * carbon_intensity_kg_per_kwh\n    \n    return {\n        'instance_type': instance_type,\n        'power_watts': power_watts,\n        'running_hours': running_hours,\n        'energy_kwh': total_energy_kwh,\n        'co2_kg': co2_emissions_kg,\n        'co2_g': co2_emissions_kg * 1000,\n        'carbon_intensity_used': carbon_intensity_kg_per_kwh\n    }\n\ndef main_ec2_co2_analysis(region: str = 'us-east-1', days_back: int = 7) -> Dict[str, Any]:\n    \"\"\"\n    Main function to perform EC2 CO2 analysis using boto3\n    \n    Args:\n        region: AWS region to analyze\n        days_back: Number of days to look back\n        \n    Returns:\n        Dictionary with complete analysis results\n    \"\"\"\n    print(f\"ğŸŒ Starting EC2 CO2 analysis for {region}\")\n    print(f\"ğŸ“… Analyzing last {days_back} days\")\n    print(f\"ğŸ”¬ Using 300g CO2/kWh carbon intensity\")\n    \n    # Define time range\n    end_time = datetime.utcnow()\n    start_time = end_time - timedelta(days=days_back)\n    \n    # Step 1: Fetch EC2 instances\n    print(\"\\nğŸ“Š Fetching EC2 instances...\")\n    instances = fetch_ec2_instances_boto3(region)\n    \n    if not instances:\n        print(\"â„¹ï¸  No running instances found\")\n        return {'instances': [], 'total_co2_kg': 0}\n    \n    print(f\"âœ… Found {len(instances)} running instances\")\n    \n    # Step 2: Analyze each instance\n    print(\"\\nâš¡ Analyzing instance emissions...\")\n    results = []\n    total_co2_kg = 0\n    total_energy_kwh = 0\n    \n    for i, instance in enumerate(instances, 1):\n        instance_id = instance['InstanceId']\n        instance_type = instance['InstanceType']\n        \n        print(f\"  {i}/{len(instances)}: {instance_id} ({instance_type})\")\n        \n        # Get running hours from CloudWatch\n        running_hours = fetch_cloudwatch_instance_hours(\n            instance_id, start_time, end_time, region\n        )\n        \n        # Calculate CO2 emissions\n        emissions = calculate_co2_emissions(instance_type, running_hours)\n        \n        # Combine instance data with emissions\n        result = {\n            **instance,\n            **emissions,\n            'analysis_period': {\n                'start': start_time.isoformat(),\n                'end': end_time.isoformat(),\n                'days': days_back\n            }\n        }\n        \n        results.append(result)\n        total_co2_kg += emissions['co2_kg']\n        total_energy_kwh += emissions['energy_kwh']\n        \n        print(f\"    ğŸ’¡ {emissions['power_watts']}W Ã— {running_hours:.1f}h = {emissions['co2_g']:.1f}g CO2\")\n    \n    # Step 3: Generate summary\n    summary = {\n        'region': region,\n        'analysis_period_days': days_back,\n        'total_instances': len(instances),\n        'total_energy_kwh': total_energy_kwh,\n        'total_co2_kg': total_co2_kg,\n        'total_co2_g': total_co2_kg * 1000,\n        'average_co2_per_instance_kg': total_co2_kg / len(instances),\n        'daily_average_co2_kg': total_co2_kg / days_back,\n        'carbon_intensity_kg_per_kwh': 0.3\n    }\n    \n    # Sort results by CO2 emissions (highest first)\n    results.sort(key=lambda x: x['co2_kg'], reverse=True)\n    \n    print(f\"\\nğŸ“ˆ ANALYSIS COMPLETE:\")\n    print(f\"   ğŸŒ¿ Total CO2: {total_co2_kg:.3f} kg ({total_co2_kg * 1000:.1f}g)\")\n    print(f\"   âš¡ Total Energy: {total_energy_kwh:.2f} kWh\")\n    print(f\"   ğŸ“Š Average per instance: {summary['average_co2_per_instance_kg']:.3f} kg\")\n    print(f\"   ğŸ“… Daily average: {summary['daily_average_co2_kg']:.3f} kg/day\")\n    \n    return {\n        'summary': summary,\n        'instances': results,\n        'timestamp': datetime.utcnow().isoformat()\n    }\n\n# Example usage (commented out to avoid AWS calls without credentials)\nif __name__ == \"__main__\":\n    print(\"ğŸš€ EC2 CO2 Calculator with boto3\")\n    print(\"ğŸ“ This script demonstrates the boto3 implementation\")\n    print(\"âš ï¸  Requires valid AWS credentials to run\")\n    print()\n    print(\"ğŸ’¡ Key boto3 functions:\")\n    print(\"   â€¢ boto3.client('ec2').describe_instances()\")\n    print(\"   â€¢ boto3.client('cloudwatch').get_metric_statistics()\")\n    print(\"   â€¢ Calculate CO2 using 300g/kWh carbon intensity\")\n    print()\n    print(\"ğŸ”§ To run with real data:\")\n    print(\"   1. Configure AWS credentials (aws configure)\")\n    print(\"   2. Uncomment the main_ec2_co2_analysis() call below\")\n    print(\"   3. Run: python3 boto3_ec2_co2_example.py\")\n    print()\n    \n    # Uncomment the line below to run with real AWS data\n    # result = main_ec2_co2_analysis('us-east-1', 7)"
